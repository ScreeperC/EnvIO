---
{"dg-publish":true,"permalink":"/type-script/algorithm//"}
---


# 常见排序算法的 TypeScript 实现

## 概述

### 算法分类

**常见排序算法可以分为以下两大类**：

- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 `O(nlogn)`，因此也称为非线性时间比较类排序。
- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

### 相关概念

-   稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
-   不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
-   时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
-   空间复杂度：

### 算法复杂度

| **算法**   | **时间复杂度（平均）** | **时间复杂度（最坏）** | **时间复杂度（最好）** | **空间复杂度**   | **稳定性** |
|----------|---------------|---------------|---------------|-------------|-----------|
| **冒泡排序** | O( n² )       | O( n² )       | O( n )        | O( 1 )      | 稳定        |
| **选择排序**   | O( n² )       | O( n² )       | O( n² )       | O( 1 )      | 不稳定       |
| **插入排序**   | O( n² )       | O( n² )       | O( n )        | O( 1 )      | 稳定        |
| **希尔排序**   | O( n$^{1.3}$ )     | O( n² )       | O( n )        | O( 1 )      | 不稳定       |
| **归并排序**   | O( nlog2n )   | O( nlog2n )   | O( n + k )    | O( nlog2n ) | 稳定        |
| **快速排序**   | O( nlog2n )   | O( n² )       | O( n + k )    | O( 1 )      | 不稳定       |
| **堆排序**    | O( nlog2n )   | O( nlog2n )   | O( n + k )    | O( 1 )      | 不稳定       |
| **计数排序**   | O( nlog2n )   | O( n + k )    | O( n + k )    | O( n + k )  | 稳定        |
| **桶排序**    | O( nlog2n )   | O( n² )       | O( n )        | O( n + k )  | 稳定        |
| **基数排序**   | O( n * k )    | O( n * k )    | O( n * k )    | O( n + k )  | 稳定        |

## 冒泡排序 ( Bubble Sort )


	冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端

### 算法描述

1. 比较相邻的元素，如果第一个比第二个大，则交换位置
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个（已经确定的元素）
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

### 动图演示

### 代码实现

```ts
    function BubbleSort ( arr: any[], len: number = arr.length ){
        let i = 0, j = 0;
        for ( ; i < len; i++ ) {
            for ( ; j < len - i - 1; j++ ) {
                if ( arr[ j ] > arr[ j + 1 ] ) continue;
                [ arr[ j ], arr[ j + 1 ] ] = [ arr[ j + 1 ], arr[ j ] ];
            }
        }
    }
```

## 选择排序（Selection Sort）

	选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

## 
### 算法描述

### 动图演示

### 代码实现

